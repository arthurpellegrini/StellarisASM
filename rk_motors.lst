


ARM Macro Assembler    Page 1 


    1 00000000         ;; programme - Pilotage 2 Moteurs Evalbot par PWM tout e
                       n ASM (configure les pwms + GPIO)
    2 00000000         
    3 00000000         ;;Les pages se réfèrent au datasheet lm3s9b92.pdf
    4 00000000         
    5 00000000         ;;Cablage :
    6 00000000         ;;pin 10/PD0/PWM0 => input PWM du pont en H DRV8801RT
    7 00000000         ;;pin 11/PD1/PWM1 => input Phase_R  du pont en H DRV8801
                       RT
    8 00000000         ;;pin 12/PD2   => input SlowDecay commune aux 2 ponts en
                        H
    9 00000000         ;;pin 98/PD5   => input Enable 12v du conv DC/DC 
   10 00000000         ;;pin 86/PH0/PWM2 => input PWM du 2nd pont en H
   11 00000000         ;;pin 85/PH1/PWM3 => input Phase du 2nd pont en H 
   12 00000000         
   13 00000000         ;;; Hexa corresponding values to pin numbers
   14 00000000         ;GPIO_0  EQU  0x1
   15 00000000         ;GPIO_1  EQU  0x2
   16 00000000         ;GPIO_2  EQU  0x4
   17 00000000         ;GPIO_5  EQU  0x20
   18 00000000         
   19 00000000         ;;; pour enable clock    0x400FE000
   20 00000000         ;SYSCTL_RCGC0 EQU  0x400FE100  ;SYSCTL_RCGC0: offset 0x1
                       00 (p271 datasheet de lm3s9b92.pdf)
   21 00000000         ;SYSCTL_RCGC2 EQU  0x400FE108  ;SYSCTL_RCGC2: offset 0x1
                       08 (p291 datasheet de lm3s9b92.pdf)
   22 00000000         
   23 00000000         ;;; General-Purpose Input/Outputs (GPIO) configuration
   24 00000000         ;PORTD_BASE  EQU  0x40007000
   25 00000000         ;GPIODATA_D  EQU  PORTD_BASE
   26 00000000         ;GPIODIR_D  EQU  PORTD_BASE+0x00000400
   27 00000000         ;GPIODR2R_D  EQU  PORTD_BASE+0x00000500
   28 00000000         ;GPIODEN_D  EQU  PORTD_BASE+0x0000051C
   29 00000000         ;GPIOPCTL_D  EQU  PORTD_BASE+0x0000052C ; GPIO Port Cont
                       rol (GPIOPCTL), offset 0x52C; p444
   30 00000000         ;GPIOAFSEL_D  EQU  PORTD_BASE+0x00000420 ; GPIO Alternat
                       e Function Select (GPIOAFSEL), offset 0x420; p426
   31 00000000         
   32 00000000         ;PORTH_BASE  EQU  0x40027000
   33 00000000         ;GPIODATA_H  EQU  PORTH_BASE
   34 00000000         ;GPIODIR_H  EQU  PORTH_BASE+0x00000400
   35 00000000         ;GPIODR2R_H  EQU  PORTH_BASE+0x00000500
   36 00000000         ;GPIODEN_H  EQU  PORTH_BASE+0x0000051C
   37 00000000         ;GPIOPCTL_H  EQU  PORTH_BASE+0x0000052C ; GPIO Port Cont
                       rol (GPIOPCTL), offset 0x52C; p444
   38 00000000         ;GPIOAFSEL_H  EQU  PORTH_BASE+0x00000420 ; GPIO Alternat
                       e Function Select (GPIOAFSEL), offset 0x420; p426
   39 00000000         
   40 00000000         ;;; Pulse Width Modulator (PWM) configuration
   41 00000000         ;PWM_BASE  EQU  0x040028000     ;BASE des Block PWM p.11
                       38
   42 00000000         ;PWMENABLE  EQU  PWM_BASE+0x008    ; p1145
   43 00000000         
   44 00000000         ;;Block PWM0 pour sorties PWM0 et PWM1 (moteur 1)
   45 00000000         ;PWM0CTL   EQU  PWM_BASE+0x040 ;p1167
   46 00000000         ;PWM0LOAD  EQU  PWM_BASE+0x050
   47 00000000         ;PWM0CMPA  EQU  PWM_BASE+0x058
   48 00000000         ;PWM0CMPB  EQU  PWM_BASE+0x05C
   49 00000000         ;PWM0GENA  EQU  PWM_BASE+0x060



ARM Macro Assembler    Page 2 


   50 00000000         ;PWM0GENB  EQU  PWM_BASE+0x064
   51 00000000         
   52 00000000         ;;Block PWM1 pour sorties PWM1 et PWM2 (moteur 2)
   53 00000000         ;PWM1CTL   EQU  PWM_BASE+0x080 
   54 00000000         ;PWM1LOAD  EQU  PWM_BASE+0x090
   55 00000000         ;PWM1CMPA  EQU  PWM_BASE+0x098
   56 00000000         ;PWM1CMPB  EQU  PWM_BASE+0x09C
   57 00000000         ;PWM1GENA  EQU  PWM_BASE+0x0A0
   58 00000000         ;PWM1GENB  EQU  PWM_BASE+0x0A4
   59 00000000         
   60 00000000         ;; Vitesse : min = 0x1D0 <=> max = 0x001
   61 00000000         ;VITESSE   EQU  0x1A2 ; Valeures plus petites => Vitesse
                        plus rapide exemple 0x192
   62 00000000         ;; Valeures plus grandes => Vitesse moins rapide exemple
                        0x1B2
   63 00000000         
   64 00000000         
   65 00000000         ;AREA    |.text|, CODE, READONLY
   66 00000000         ;ENTRY
   67 00000000         
   68 00000000         ;;; The EXPORT command specifies that a symbol can be ac
                       cessed by other shared objects or executables.
   69 00000000         ;EXPORT MOTEUR_INIT
   70 00000000         ;EXPORT MOTEUR_DROIT_ON
   71 00000000         ;EXPORT  MOTEUR_DROIT_OFF
   72 00000000         ;EXPORT  MOTEUR_DROIT_AVANT
   73 00000000         ;EXPORT  MOTEUR_DROIT_ARRIERE
   74 00000000         ;EXPORT  MOTEUR_DROIT_INVERSE 
   75 00000000         ;EXPORT MOTEUR_GAUCHE_ON
   76 00000000         ;EXPORT  MOTEUR_GAUCHE_OFF
   77 00000000         ;EXPORT  MOTEUR_GAUCHE_AVANT
   78 00000000         ;EXPORT  MOTEUR_GAUCHE_ARRIERE
   79 00000000         ;EXPORT  MOTEUR_GAUCHE_INVERSE
   80 00000000         
   81 00000000         
   82 00000000         ;MOTEUR_INIT 
   83 00000000         ;ldr r6, = SYSCTL_RCGC0
   84 00000000         ;ldr r0, [R6]
   85 00000000         ;ORR r0, r0, #0x00100000  ;;bit 20 = PWM recoit clock: O
                       N (p271) 
   86 00000000         ;str r0, [r6]
   87 00000000         
   88 00000000         ;;ROM_SysCtlPWMClockSet(SYSCTL_PWMDIV_1);PWM clock is pr
                       ocessor clock /1
   89 00000000         ;;Je ne fais rien car par defaut = OK!!
   90 00000000         ;;*(int *) (0x400FE060)= *(int *)(0x400FE060)...;
   91 00000000         
   92 00000000         ;;RCGC2 :  Enable port D GPIO(p291 ) car Moteur Droit su
                       r port D 
   93 00000000         ;ldr r6, = SYSCTL_RCGC2
   94 00000000         ;ldr r0, [R6]   
   95 00000000         ;ORR r0, r0, #0x08  ;; Enable port D GPIO 
   96 00000000         ;str r0, [r6]
   97 00000000         
   98 00000000         ;;MOT2 : RCGC2 :  Enable port H GPIO  (2eme moteurs)
   99 00000000         ;ldr r6, = SYSCTL_RCGC2
  100 00000000         ;ldr r0, [R6] 
  101 00000000         ;ORR r0, r0, #0x80  ;; Enable port H GPIO 
  102 00000000         ;str r0, [r6] 



ARM Macro Assembler    Page 3 


  103 00000000         
  104 00000000         ;nop
  105 00000000         ;nop
  106 00000000         ;nop
  107 00000000         
  108 00000000         ;;;Pin muxing pour PWM, port D, reg. GPIOPCTL(p444), 4bi
                       ts de PCM0=0001<=>PWM (voir p1261)
  109 00000000         ;;;il faut mettre 1 pour avoir PD0=PWM0 et PD1=PWM1
  110 00000000         ;ldr r6, = GPIOPCTL_D
  111 00000000         ;;ldr r0, [R6]   ;; *(int *)(0x40007000+0x0000052C)=1;
  112 00000000         ;;ORR r0, r0, #0x01 ;; Port D, pin 1 = PWM 
  113 00000000         ;mov r0, #0x01  
  114 00000000         ;str r0, [r6]
  115 00000000         
  116 00000000         ;;;MOT2 : Pin muxing pour PWM, port H, reg. GPIOPCTL(p44
                       4), 4bits de PCM0=0001<=>PWM (voir p1261)
  117 00000000         ;;;il faut mettre mux = 2 pour avoir PH0=PWM2 et PH1=PWM
                       3
  118 00000000         ;ldr r6, = GPIOPCTL_H 
  119 00000000         ;mov r0, #0x02 
  120 00000000         ;str r0, [r6]
  121 00000000         
  122 00000000         ;;;Alternate Function Select (p 426), PD0 utilise alerna
                       te fonction (PWM au dessus)
  123 00000000         ;;;donc PD0 = 1
  124 00000000         ;ldr r6, = GPIOAFSEL_D
  125 00000000         ;ldr r0, [R6]    ;*(int *)(0x40007000+0x00000420)= *(int
                        *)(0x40007000+0x00000420) | 0x00000001;
  126 00000000         ;ORR r0, r0, #0x01 ;
  127 00000000         ;str r0, [r6]
  128 00000000         
  129 00000000         ;;;MOT2 : Alternate Function Select (p 426), PH0 utilise
                        PWM donc Alternate funct
  130 00000000         ;;;donc PH0 = 1
  131 00000000         ;ldr r6, = GPIOAFSEL_H
  132 00000000         ;ldr r0, [R6]    ;*(int *)(0x40007000+0x00000420)= *(int
                        *)(0x40007000+0x00000420) | 0x00000001;
  133 00000000         ;ORR r0, r0, #0x01 ;
  134 00000000         ;str r0, [r6]
  135 00000000         
  136 00000000         ;;;-----------PWM0 pour moteur 1 connecté à PD0
  137 00000000         ;;;PWM0 produit PWM0 et PWM1 output
  138 00000000         ;;;Config Modes PWM0 + mode GenA + mode GenB
  139 00000000         ;ldr r6, = PWM0CTL
  140 00000000         ;mov r0, #2  ;Mode up-down-up-down, pas synchro
  141 00000000         ;str r0, [r6] 
  142 00000000         
  143 00000000         ;ldr r6, =PWM0GENA ;en decomptage, qd comparateurA = com
                       pteur => sortie pwmA=0
  144 00000000         ;;en comptage croissant, qd comparateurA = compteur => s
                       ortie pwmA=1
  145 00000000         ;mov r0, #0x0B0  ;0B0=10110000 => ACTCMPBD=00 (B down:ri
                       en), ACTCMPBU=00(B up rien)
  146 00000000         ;str r0, [r6] ;ACTCMPAD=10 (A down:pwmA low), ACTCMPAU=1
                       1 (A up:pwmA high) , ACTLOAD=00,ACTZERO=00  
  147 00000000         
  148 00000000         ;ldr r6, =PWM0GENB;en comptage croissant, qd comparateur
                       B = compteur => sortie pwmA=1
  149 00000000         ;mov r0, #0x0B00 ;en decomptage, qd comparateurB = compt



ARM Macro Assembler    Page 4 


                       eur => sortie pwmB=0
  150 00000000         ;str r0, [r6] 
  151 00000000         ;;Config Compteur, comparateur A et comparateur B
  152 00000000         ;;;#define PWM_PERIOD (ROM_SysCtlClockGet() / 16000),
  153 00000000         ;;;en mesure : SysCtlClockGet=0F42400h, /16=0x3E8, 
  154 00000000         ;;;on divise par 2 car moteur 6v sur alim 12v
  155 00000000         ;ldr r6, =PWM0LOAD ;PWM0LOAD=periode/2 =0x1F4
  156 00000000         ;mov r0, #0x1F4
  157 00000000         ;str r0,[r6]
  158 00000000         
  159 00000000         ;ldr r6, =PWM0CMPA ;Valeur rapport cyclique : pour 10% =
                       > 1C2h si clock = 0F42400
  160 00000000         ;mov r0, #VITESSE
  161 00000000         ;str r0, [r6]  
  162 00000000         
  163 00000000         ;ldr r6, =PWM0CMPB ;PWM0CMPB recoit meme valeur. (rappor
                       t cyclique depend de CMPA)
  164 00000000         ;mov r0, #0x1F4 
  165 00000000         ;str r0, [r6]
  166 00000000         
  167 00000000         ;;Control PWM : active PWM Generator 0 (p1167): Enable+u
                       p/down + Enable counter debug mod
  168 00000000         ;ldr r6, =PWM0CTL 
  169 00000000         ;ldr r0, [r6] 
  170 00000000         ;ORR r0, r0, #0x07
  171 00000000         ;str r0, [r6]
  172 00000000         
  173 00000000         ;;;-----------PWM2 pour moteur 2 connecté à PH0
  174 00000000         ;;;PWM1block produit PWM2 et PWM3 output
  175 00000000         ;;;Config Modes PWM2 + mode GenA + mode GenB
  176 00000000         ;ldr r6, = PWM1CTL
  177 00000000         ;mov r0, #2  ;Mode up-down-up-down, pas synchro
  178 00000000         ;str r0, [r6] ;*(int *)(0x40028000+0x040)=2;
  179 00000000         
  180 00000000         ;ldr r6, =PWM1GENA ;en decomptage, qd comparateurA = com
                       pteur => sortie pwmA=0
  181 00000000         ;;en comptage croissant, qd comparateurA = compteur => s
                       ortie pwmA=1
  182 00000000         ;mov r0, #0x0B0  ;0B0=10110000 => ACTCMPBD=00 (B down:ri
                       en), ACTCMPBU=00(B up rien)
  183 00000000         ;str r0, [r6] ;ACTCMPAD=10 (A down:pwmA low), ACTCMPAU=1
                       1 (A up:pwmA high) , ACTLOAD=00,ACTZERO=00  
  184 00000000         
  185 00000000         ;;*(int *)(0x40028000+0x060)=0x0B0; //
  186 00000000         ;ldr r6, =PWM1GENB ;*(int *)(0x40028000+0x064)=0x0B00;
  187 00000000         ;mov r0, #0x0B00 ;en decomptage, qd comparateurB = compt
                       eur => sortie pwmB=0
  188 00000000         ;str r0, [r6] ;en comptage croissant, qd comparateurB = 
                       compteur => sortie pwmA=1
  189 00000000         ;;Config Compteur, comparateur A et comparateur B
  190 00000000         ;;;#define PWM_PERIOD (ROM_SysCtlClockGet() / 16000),
  191 00000000         ;;;en mesure : SysCtlClockGet=0F42400h, /16=0x3E8, 
  192 00000000         ;;;on divise par 2 car moteur 6v sur alim 12v
  193 00000000         ;;*(int *)(0x40028000+0x050)=0x1F4; //PWM0LOAD=periode/2
                        =0x1F4
  194 00000000         ;ldr r6, =PWM1LOAD
  195 00000000         ;mov r0, #0x1F4
  196 00000000         ;str r0,[r6]
  197 00000000         



ARM Macro Assembler    Page 5 


  198 00000000         ;ldr r6, =PWM1CMPA ;Valeur rapport cyclique : pour 10% =
                       > 1C2h si clock = 0F42400
  199 00000000         ;mov r0, #VITESSE
  200 00000000         ;str r0, [r6]  ;*(int *)(0x40028000+0x058)=0x01C2;
  201 00000000         
  202 00000000         ;ldr r6, =PWM1CMPB ;PWM0CMPB recoit meme valeur. (CMPA d
                       epend du rapport cyclique)
  203 00000000         ;mov r0, #0x1F4 ; *(int *)(0x40028000+0x05C)=0x1F4; 
  204 00000000         ;str r0, [r6]
  205 00000000         
  206 00000000         ;;Control PWM : active PWM Generator 0 (p1167): Enable+u
                       p/down + Enable counter debug mod
  207 00000000         ;ldr r6, =PWM1CTL 
  208 00000000         ;ldr r0, [r6] ;*(int *) (0x40028000+0x40)= *(int *)(0x40
                       028000+0x40) | 0x07;
  209 00000000         ;ORR r0, r0, #0x07
  210 00000000         ;str r0, [r6]  
  211 00000000         
  212 00000000         ;;;-----Fin config des PWMs   
  213 00000000         
  214 00000000         ;;PORT D OUTPUT pin0 (pwm)=pin1(direction)=pin2(slow dec
                       ay)=pin5(12v enable)
  215 00000000         ;ldr r6, =GPIODIR_D 
  216 00000000         ;ldr r0, [r6]
  217 00000000         ;ORR r0, #(GPIO_0+GPIO_1+GPIO_2+GPIO_5)
  218 00000000         ;str r0,[r6]
  219 00000000         ;;Port D, 2mA les meme
  220 00000000         ;ldr r6, =GPIODR2R_D ; 
  221 00000000         ;ldr r0, [r6]
  222 00000000         ;ORR r0, #(GPIO_0+GPIO_1+GPIO_2+GPIO_5)
  223 00000000         ;str r0,[r6]
  224 00000000         ;;Port D, Digital Enable
  225 00000000         ;ldr r6, =GPIODEN_D ;
  226 00000000         ;ldr r0, [r6]
  227 00000000         ;ORR r0, #(GPIO_0+GPIO_1+GPIO_2+GPIO_5) 
  228 00000000         ;str r0,[r6] 
  229 00000000         ;;Port D : mise à 1 de slow Decay et 12V et mise à 0 pou
                       r dir et pwm
  230 00000000         ;ldr r6, =(GPIODATA_D+((GPIO_0+GPIO_1+GPIO_2+GPIO_5)<<2)
                       ) 
  231 00000000         ;mov r0, #(GPIO_2+GPIO_5) ; #0x24
  232 00000000         ;str r0,[r6]
  233 00000000         
  234 00000000         ;;MOT2, PH1 pour sens moteur ouput
  235 00000000         ;ldr r6, =GPIODIR_H 
  236 00000000         ;mov r0, #0x03 ; 
  237 00000000         ;str r0,[r6]
  238 00000000         ;;Port H, 2mA les meme
  239 00000000         ;ldr r6, =GPIODR2R_H
  240 00000000         ;mov r0, #0x03 
  241 00000000         ;str r0,[r6]
  242 00000000         ;;Port H, Digital Enable
  243 00000000         ;ldr r6, =GPIODEN_H
  244 00000000         ;mov r0, #0x03 
  245 00000000         ;str r0,[r6] 
  246 00000000         ;;Port H : mise à 1 pour dir 
  247 00000000         ;ldr r6, =(GPIODATA_H +(GPIO_1<<2))
  248 00000000         ;mov r0, #0x02
  249 00000000         ;str r0,[r6]  



ARM Macro Assembler    Page 6 


  250 00000000         
  251 00000000         ;BX LR ; FIN du sous programme d'init.
  252 00000000         
  253 00000000         ;;Enable PWM0 (bit 0) et PWM2 (bit 2) p1145 
  254 00000000         ;;Attention ici c'est les sorties PWM0 et PWM2
  255 00000000         ;;qu'on controle, pas les blocks PWM0 et PWM1!!!
  256 00000000         ;MOTEUR_DROIT_ON
  257 00000000         ;;Enable sortie PWM0 (bit 0), p1145 
  258 00000000         ;ldr r6, =PWMENABLE
  259 00000000         ;ldr r0, [r6]
  260 00000000         ;orr r0, #0x01 ;bit 0 à 1
  261 00000000         ;str r0, [r6]
  262 00000000         ;BX LR
  263 00000000         
  264 00000000         ;MOTEUR_DROIT_OFF 
  265 00000000         ;ldr r6, =PWMENABLE
  266 00000000         ;ldr r0, [r6]
  267 00000000         ;and r0, #0x0E ;bit 0 à 0
  268 00000000         ;str r0, [r6]
  269 00000000         ;BX LR
  270 00000000         
  271 00000000         ;0
  272 00000000         ;ldr r6, =PWMENABLE
  273 00000000         ;ldr r0, [r6]
  274 00000000         ;orr r0, #0x04 ;bit 2 à 1
  275 00000000         ;str r0, [r6]
  276 00000000         ;BX LR
  277 00000000         
  278 00000000         ;MOTEUR_GAUCHE_OFF
  279 00000000         ;ldr r6, =PWMENABLE
  280 00000000         ;ldr r0, [r6]
  281 00000000         ;and r0, #0x0B ;bit 2 à 0
  282 00000000         ;str r0, [r6]
  283 00000000         ;BX LR
  284 00000000         
  285 00000000         ;MOTEUR_DROIT_ARRIERE
  286 00000000         ;;Inverse Direction (GPIO_D1)
  287 00000000         ;ldr r6, =(GPIODATA_D+(GPIO_1<<2)) 
  288 00000000         ;mov r0, #0
  289 00000000         ;str r0,[r6]
  290 00000000         ;BX LR
  291 00000000         
  292 00000000         ;MOTEUR_DROIT_AVANT
  293 00000000         ;;Inverse Direction (GPIO_D1)
  294 00000000         ;ldr r6, =(GPIODATA_D+(GPIO_1<<2)) 
  295 00000000         ;mov r0, #2
  296 00000000         ;str r0,[r6]
  297 00000000         ;BX LR
  298 00000000         
  299 00000000         ;MOTEUR_GAUCHE_ARRIERE
  300 00000000         ;;Inverse Direction (GPIO_D1)
  301 00000000         ;ldr r6, =(GPIODATA_H+(GPIO_1<<2)) 
  302 00000000         ;mov r0, #2 ; contraire du moteur Droit
  303 00000000         ;str r0,[r6]
  304 00000000         ;BX LR  
  305 00000000         
  306 00000000         ;MOTEUR_GAUCHE_AVANT
  307 00000000         ;;Inverse Direction (GPIO_D1)
  308 00000000         ;ldr r6, =(GPIODATA_H+(GPIO_1<<2)) 



ARM Macro Assembler    Page 7 


  309 00000000         ;mov r0, #0
  310 00000000         ;str r0,[r6]
  311 00000000         ;BX LR  
  312 00000000         
  313 00000000         ;MOTEUR_DROIT_INVERSE
  314 00000000         ;;Inverse Direction (GPIO_D1)
  315 00000000         ;ldr r6, =(GPIODATA_D+(GPIO_1<<2)) 
  316 00000000         ;ldr r1, [r6]
  317 00000000         ;EOR r0, r1, #GPIO_1
  318 00000000         ;str r0,[r6]
  319 00000000         ;BX LR
  320 00000000         
  321 00000000         ;MOTEUR_GAUCHE_INVERSE
  322 00000000         ;;Inverse Direction (GPIO_D1)
  323 00000000         ;ldr r6, =(GPIODATA_H+(GPIO_1<<2)) 
  324 00000000         ;ldr r1, [r6]
  325 00000000         ;EOR r0, r1, #GPIO_1
  326 00000000         ;str r0,[r6]
  327 00000000         ;BX LR
  328 00000000         
  329 00000000         ;END
                       
Command Line: --debug --xref --cpu=Cortex-M3 --apcs=interwork --depend=.\rk_mot
ors.d -o.\rk_motors.o -I"C:\Program Files\Keil\ARM\RV31\INC" -I"C:\Program File
s\Keil\ARM\CMSIS\Include" -I"C:\Program Files\Keil\ARM\Inc\Luminary" --predefin
e="__EVAL SETA 1" --predefine="__MICROLIB SETA 1" --list=.\rk_motors.lst rk_mot
ors.s
332 symbols in table
